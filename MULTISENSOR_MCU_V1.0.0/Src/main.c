/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "temhumsensor.h"
#include "Ucglib.h"
#include "timer.h"
#include "stm32f401re_i2c.h"
#include <string.h>
#include "Ucglib.h"
#include "stm32f401re_rcc.h"
#include "stm32f401re_gpio.h"
#include "stm32f401re_spi.h"

//Private Macro
#define I2C_SPEED								400000
#define I2Cx_RCC								RCC_APB1Periph_I2C1
#define I2Cx_SENSOR								I2C1
#define I2C_GPIO_RCC		    				RCC_AHB1Periph_GPIOB
#define I2C_GPIO								GPIOB
#define I2C_PIN_SDA			    			 	GPIO_Pin_9
#define I2C_PIN_SCL			    			 	GPIO_Pin_8
#define SCAN_CYCLE								1000 // Chu ki quet 1s


static ucg_t ucg;
static uint32_t time_initial;
static uint16_t temperature, humidity;
char src1[20] = "";
char src2[20] = "";


static void I2C_Master_Init(void);
static void TemHumSensor_readRegister(
    uint8_t address,
    uint8_t* pAddressReg,
    uint8_t* pDataRead,
    uint8_t byLengthData,
    uint16_t wDelay
);
static void processGetValueSensor(void);
uint32_t TemHumSensor_getTemperature(void);
uint8_t CalculateCRC8(uint8_t *pByData, uint8_t byLength);
uint32_t TemHumSensor_getHumidity(void);


int main(void)
{

    SystemCoreClockUpdate();
    I2C_Master_Init();
    TimerInit();
    Ucglib4WireSWSPI_begin(&ucg, UCG_FONT_MODE_SOLID);
    ucg_ClearScreen(&ucg);
    ucg_SetFont(&ucg, ucg_font_profont12_8f);
    ucg_SetColor(&ucg, 0, 255, 255, 255);
    ucg_SetColor(&ucg, 1, 0, 0, 0);
    ucg_SetRotate90(&ucg);
    ucg_DrawString(&ucg, 12, 32, 0, "Assignment 2");
    time_initial = GetMilSecTick();

    while (1)
    {
        processGetValueSensor();
        processTimerScheduler();
    }
}

static void I2C_Master_Init(void)
{
	// Initialization struct
	I2C_InitTypeDef I2C_InitStruct;
	GPIO_InitTypeDef GPIO_InitStruct;

	RCC_APB1PeriphClockCmd(I2Cx_RCC, ENABLE);
	I2C_InitStruct.I2C_ClockSpeed = I2C_SPEED;
	I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;
	I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;
	I2C_InitStruct.I2C_OwnAddress1 = 0x00;
	I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;
	I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
	I2C_Init(I2Cx_SENSOR, &I2C_InitStruct);
	I2C_Cmd(I2Cx_SENSOR, ENABLE);

	RCC_AHB1PeriphClockCmd(I2C_GPIO_RCC, ENABLE);
	GPIO_InitStruct.GPIO_Pin = I2C_PIN_SCL | I2C_PIN_SDA;
	GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;
	GPIO_InitStruct.GPIO_PuPd  = GPIO_PuPd_NOPULL;
	GPIO_Init(I2C_GPIO, &GPIO_InitStruct);

	GPIO_PinAFConfig(I2C_GPIO, GPIO_PinSource8, GPIO_AF_I2C1);

	GPIO_PinAFConfig(I2C_GPIO, GPIO_PinSource9, GPIO_AF_I2C1);

}
/*void i2c_start(void)
{

	while (I2C_GetFlagStatus(I2Cx_SENSOR, I2C_FLAG_BUSY));

	I2C_GenerateSTART(I2Cx_SENSOR, ENABLE);

	while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_MODE_SELECT));
}

void i2c_stop(void)
{
	// Generate I2C stop condition
	I2C_GenerateSTOP(I2Cx_SENSOR, ENABLE);
}*/
/*
void i2c_address_direction(uint8_t address, uint8_t direction)
{
	I2C_Send7bitAddress(I2Cx_SENSOR, address, direction);

	if (direction == I2C_Direction_Transmitter)
	{
		while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));
	}
	else if (direction == I2C_Direction_Receiver)
	{
		while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));
	}
}


void i2c_transmit(uint8_t byte)
{
	I2C_SendData(I2Cx_SENSOR, byte);

	while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_BYTE_TRANSMITTED));
}

uint8_t i2c_receive_ack(void)
{
	I2C_AcknowledgeConfig(I2Cx_SENSOR, ENABLE);

	while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_BYTE_RECEIVED));

	return I2C_ReceiveData(I2Cx_SENSOR);
}


uint8_t i2c_receive_nack(void)
{

	I2C_AcknowledgeConfig(I2Cx_SENSOR, DISABLE);

	while (!I2C_CheckEvent(I2Cx_SENSOR, I2C_EVENT_MASTER_BYTE_RECEIVED));

	return I2C_ReceiveData(I2Cx_SENSOR);
}*/

static void
TemHumSensor_readRegister(
    uint8_t address,
    uint8_t* pAddressReg,
    uint8_t* pDataRead,
    uint8_t byLengthData,
    uint16_t wDelay
) {
    uint8_t byLenCmd = pAddressReg[0];

    i2c_start();
	i2c_address_direction(address << 1, I2C_Direction_Transmitter);

    for (uint8_t i = 1; i < byLenCmd; i++) {
        i2c_transmit(pAddressReg[i]);
    }

//    if (wDelay > 0) {
//        delay_ms(wDelay);
//    }

	i2c_stop();
	i2c_start();
    i2c_address_direction(address << 1, I2C_Direction_Receiver);

    for (uint8_t i = 0; i < byLengthData; i++)
	{
		if (i == (byLengthData - 1))
		{
			pDataRead[i] = i2c_receive_nack();
		}
		else
		{
			pDataRead[i] = i2c_receive_ack();
		}
	}
	i2c_stop();
}

uint8_t CalculateCRC8(uint8_t *pByData, uint8_t byLength)
{
    // Khai báo biến
    uint8_t i, j = 0;         // Biến đếm cho vòng lặp (i cho bit, j cho byte)
    uint16_t wCrc = 0;        // Biến lưu trữ CRC tạm thời (dùng 16-bit để tính toán)
    uint8_t *pByCurrData = pByData; // Con trỏ cục bộ để duyệt qua dữ liệu

    // Vòng lặp ngoài: Duyệt qua từng byte của dữ liệu đầu vào
    for (j = 0; j < byLength; j++, pByCurrData++) {
        // 1. XOR byte dữ liệu hiện tại vào byte cao của wCrc
        //    - Lấy byte dữ liệu hiện tại (*pByCurrData)
        //    - Chuyển kiểu sang uint16_t
        //    - Dịch trái 8 bit để đưa nó lên byte cao (ví dụ: 0xAB -> 0xAB00)
        //    - XOR kết quả vào wCrc
        wCrc ^= ((uint16_t)(*pByCurrData) << 8);

        // 2. Vòng lặp trong: Xử lý 8 bit cho byte dữ liệu vừa được XOR vào
        for (i = 0; i < 8; i++) {
            // 3. Kiểm tra bit cao nhất (MSB) của wCrc (bit thứ 15)
            if ((wCrc & 0x8000) != 0) {
                // 4. Nếu MSB là 1, XOR wCrc với đa thức sinh (polynomial)
                //    Đa thức ở đây được biểu diễn một cách cụ thể: (0x1310 << 3)
                //    0x1310 << 3 = 0x9880 (Đây có vẻ là một cách biểu diễn cụ thể,
                //                          không hoàn toàn giống các đa thức CRC-8 chuẩn như 0x07 hay 0x31)
                wCrc ^= (0x1310 << 3); // XOR với đa thức nếu MSB=1
            }
            // 5. Dịch trái wCrc đi 1 bit để xử lý bit tiếp theo
            wCrc <<= 1;
        }
    }

    // 6. Sau khi xử lý hết các byte dữ liệu, kết quả CRC-8 nằm ở byte cao của wCrc
    //    - Dịch phải wCrc 8 bit để đưa byte cao xuống byte thấp
    //    - Dùng phép AND với 0xFF để chỉ lấy 8 bit thấp (chính là kết quả CRC-8)
    return ((wCrc >> 8) & 0xFF);
}

uint32_t TemHumSensor_getTemperature(void)
{
	uint32_t wRetval_Temp;
    uint8_t pByRetval[3] = { 0 };
    uint8_t byCheckCRC = 0;
    uint8_t CMD_MEASURE_TEMP[2] =  { 2, 0xE3 };

    TemHumSensor_readRegister(SI7020_ADDR, CMD_MEASURE_TEMP, pByRetval, 3, 0);
    byCheckCRC = CalculateCRC8(pByRetval, 2);

    /* Check CRC value */
    if (byCheckCRC == pByRetval[2]) {
    }
    else {
        return 0;
    }

    wRetval_Temp = (pByRetval[0] << 8) + pByRetval[1];
    wRetval_Temp = ((wRetval_Temp * 17572) >> 16) - 4685;

    return wRetval_Temp;
}

uint32_t TemHumSensor_getHumidity(void)
{
	uint32_t wRetval_Humi;
    uint8_t pByRetval[3] = { 0 };
    uint8_t byCheckCRC = 0;
    uint8_t CMD_MEASURE_TEMP[2] =  { 2, 0xE5 };

    TemHumSensor_readRegister(SI7020_ADDR, CMD_MEASURE_TEMP, pByRetval, 3, 0);
    byCheckCRC = CalculateCRC8(pByRetval, 2);

    /* Check CRC value */
    if (byCheckCRC == pByRetval[2]) {
    }
    else {
        return 0;
    }

    wRetval_Humi = (pByRetval[0] << 8) + pByRetval[1];
    wRetval_Humi = ((wRetval_Humi * 12500) >> 16) - 600;

    return wRetval_Humi;
}


static void processGetValueSensor(void)
{
    uint32_t dwTimeCurrent;
    static uint32_t dwTimeTotal, dwTimeInit;
//    uint16_t temperature, humidity;
    dwTimeCurrent = GetMilSecTick();

    if (dwTimeCurrent >= dwTimeInit)
    {
        dwTimeTotal += dwTimeCurrent - dwTimeInit;
    }
    else
    {
        dwTimeTotal += 0xFFFFFFFFU - dwTimeCurrent + dwTimeInit;
    }

    if (dwTimeTotal >= SCAN_CYCLE)
    {
        // Time scan 1s
        dwTimeTotal = 0;
		temperature = (uint16_t)(TemHumSensor_getTemperature() / 100);
		humidity = (uint16_t)(TemHumSensor_getHumidity() / 100);

		// Display output
		memset(src1, 0, sizeof(src1));
		sprintf(src1, "Temp = %d oC", temperature);
		ucg_DrawString(&ucg, 5, 64, 0, src1);

		memset(src2, 0, sizeof(src2));
		sprintf(src2, "Humi = %d %%", humidity);
		ucg_DrawString(&ucg, 5, 96, 0, src2);

    }
    dwTimeInit = dwTimeCurrent;
}

