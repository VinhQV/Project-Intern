/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stm32f401re_rcc.h>
#include <stm32f401re_gpio.h>
#include <stm32f401re_adc.h>
#include <stm32f401re_usart.h>
#include <timer.h>

/* Private macro -------------------------------------------------------------*/
#define USART2_TX				GPIO_Pin_2
#define USART2_Baud				9600

#define GPIO_PIN_SET			1
#define GPIO_PIN_RESET			0

#define LAND_GPIO_PIN			GPIO_Pin_4
#define LAND_GPIO_PORT			GPIOA
#define LAND_GPIO_RCC			RCC_AHB1Periph_GPIOA

#define PUMP_GPIO_PIN			GPIO_Pin_8
#define PUMP_GPIO_PORT			GPIOC
#define PUMP_GPIO_RCC			RCC_AHB1Periph_GPIOC

#define ADC_VALUE_DRY 			(3000.0f)
#define ADC_VALUE_WET 			(1500.0f)
static void SoilMoisture_Init(void)
{
	GPIO_InitTypeDef	GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd( LAND_GPIO_RCC, ENABLE);
	//Cau hinh chan PA2 cho do am dat
	GPIO_InitStructure.GPIO_Pin = LAND_GPIO_PIN;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_Init( LAND_GPIO_PORT, &GPIO_InitStructure);
}


static void ADCSoilMoisture_Init(void)
{
	ADC_InitTypeDef			ADC_InitStructure;
	ADC_CommonInitTypeDef	ADC_CommonInitStructure;
	//Enable peripheral clocks
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	ADC_DeInit();

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
	ADC_CommonInit(&ADC_CommonInitStructure);

	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfConversion = 1;
	ADC_Init(ADC1, &ADC_InitStructure);

	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_144Cycles);

//	ADC_TempSensorVrefintCmd(ENABLE);

	ADC_Cmd(ADC1, ENABLE);
}
static void Measure_Soil_Moisture(void)
{
	    float SoilMoistureRawADC; // Giá trị ADC thô đọc từ cảm biến
	    float SoilMoisturePercent; // Giá trị độ ẩm tính theo phần trăm


	    while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);

	    // Đọc giá trị ADC thô từ cảm biến độ ẩm đất được kết nối với ADC1
	    SoilMoistureRawADC = (float)ADC_GetConversionValue(ADC1);


	    float adcRange = ADC_VALUE_DRY - ADC_VALUE_WET;

	    if (adcRange <= 0) {

	        SoilMoisturePercent = 0.0f;
	    } else {

	        SoilMoisturePercent = 100.0f * (ADC_VALUE_DRY - SoilMoistureRawADC) / adcRange;
	    }

	    // Giới hạn giá trị phần trăm trong khoảng hợp lệ [0, 100]
	    if (SoilMoisturePercent > 100.0f) {
	        SoilMoisturePercent = 100.0f;
	    } else if (SoilMoisturePercent < 0.0f) {
	        SoilMoisturePercent = 0.0f;
	    }

	    uint16_t moistureIntToSend = (uint16_t)SoilMoisturePercent;
	    USART_SendData(USART2, moistureIntToSend);
}
static void USART2_Init(void)
{

	GPIO_InitTypeDef		GPIO_InitStructure;
	USART_InitTypeDef		USART_InitStructure;
	// Enable GPIO clock
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	// Configure USART Tx as alternate function push-pull-
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_InitStructure.GPIO_Pin = USART2_TX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// Connect USART pins-
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);

	// Enable USART clock-
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);

	USART_InitStructure.USART_BaudRate = USART2_Baud;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);
	// Enable USART-
	USART_Cmd(USART2, ENABLE);
}

static void MultiSensorScan(void)
{
    uint32_t dwTimeCurrent;
    static uint32_t dwTimeTotal, dwTimeInit;

    dwTimeCurrent = GetMilSecTick();

    if (dwTimeCurrent >= dwTimeInit)
    {
        dwTimeTotal += dwTimeCurrent - dwTimeInit;
    }
    else
    {
        dwTimeTotal += 0xFFFFFFFFU - dwTimeCurrent + dwTimeInit;
    }

    if (dwTimeTotal >= 1000)
    {
        // Time scan 1s
        dwTimeTotal = 0;
        Measure_Soil_Moisture();
    }
    dwTimeInit = dwTimeCurrent;
}

static void AppInitCommon(void)
{
	  // Use clock is 84MHz-
	  SystemCoreClockUpdate();

	  // Initializes system tick-
	  TimerInit();

	  // Initializes Read Temperature-
	  ADCSoilMoisture_Init();

	  // Initializes USART-
	  USART2_Init();

	  //Start ADC-
	  ADC_SoftwareStartConv(ADC1);

	  SoilMoisture_Init();
}

int main(void)
{
	AppInitCommon();
    /* Loop forever */
	while(1)
	{
		MultiSensorScan();
	}
}
