/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <stm32f401re_rcc.h>
#include <stm32f401re_gpio.h>
#include <stm32f401re_tim.h>
#include <misc.h>
#include <stdbool.h>
#include <timer.h>
#include <stm32f401re_usart.h>
#include <stm32f401re_adc.h>
#include <button.h>
#include <eventbutton.h>
#include "eventman.h"

/* Private macro -------------------------------------------------------------*/
#define USART2_TX				GPIO_Pin_2		//PA2
#define USART2_Baud				9600

#define ADC_VALUE_DRY 			(3000.0f)
#define ADC_VALUE_WET 			(1500.0f)

#define GPIO_PIN_SET			1
#define GPIO_PIN_RESET			0

#define LED_GPIO_PORT           GPIOC
#define LED_GPIO_PIN            GPIO_Pin_6 		//PC6
#define LED_GPIO_RCC 			RCC_AHB1Periph_GPIOC

#define LAND_GPIO_PIN			GPIO_Pin_4		//PA4
#define LAND_GPIO_PORT			GPIOA
#define LAND_GPIO_RCC			RCC_AHB1Periph_GPIOA

#define PUMP_GPIO_PIN			GPIO_Pin_8		//PC8
#define PUMP_GPIO_PORT			GPIOC
#define PUMP_GPIO_RCC			RCC_AHB1Periph_GPIOC

#define BUTTON_GPIO_PIN 		GPIO_Pin_3		//PB3
#define BUTTON_GPIO_PORT		GPIOB
#define BUTTON_GPIO_RCC			RCC_AHB1Periph_GPIOB

#define SENSOR_READ_INTERVAL_MS  			2000

volatile uint8_t ledState = 0;
volatile uint8_t autoPumpState = 0;
volatile uint8_t buttonPressed = 0;

bool autoRunPumpStatus = 1; // mac dinh bat


typedef enum {
    PUMP_IDLE,   // Bơm đang tắt/nghỉ
    PUMP_RUNNING // Bơm đang chạy
} PumpState;

volatile PumpState currentPumpState = PUMP_IDLE; // Trạng thái ban đầu
volatile uint16_t latestHumidityPercent;
static void SoilMoisture_Init(void);
static void TimeBasic_Init(void);
static void AutomaticPump_Init(void);
static void Led_Init(void);
static void Led_Control(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, uint8_t status);
static void ButtonBoard_Init(void);
void Delay_ms( uint32_t ms);
static void ADCSoilMoisture_Init(void);
static void USART2_Init(void);
static void processAutoRunPump();
static void UpdateSoilHumidity(void *pArg);
static uint8_t sensorUpdateTimerId = NO_TIMER;
static uint8_t autoPumpTimerId = NO_TIMER;
static void  DeviceStateMachine(uint8_t event);
static uint8_t Pump_GetLogic(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
static int eCurrentState;
bool checkPump = 0;

//Doi ten kieu liet ke
typedef enum{
	EVENT_EMPTY, EVENT_APP_INIT, EVENT_APP_FLUSHMEM_READY
}event_api_t, *event_api_p;

typedef enum{
	STATE_APP_STARTUP, STATE_APP_IDLE, STATE_APP_RESET
}state_app_t;


static void SetStateApp(state_app_t state)
{
	// Set state of application
	eCurrentState = state;
}

static state_app_t GetStateApp()
{
	//Return state of application
	return eCurrentState;
}


//Goi ham su kien
static void AppStateManager(uint8_t event)
{
	switch(GetStateApp())
	{
		case STATE_APP_STARTUP:
			if(event == EVENT_APP_INIT)
			{
				//Load configuration
				SetStateApp(STATE_APP_IDLE);
			}
			break;
		case STATE_APP_IDLE:
			{
				DeviceStateMachine(event);// anh dat breakpoint o day nen biet dc gia tri event la 2
			}
			break;
		case STATE_APP_RESET:
			break;
		default:
			break;
	}
}


int main(void)
{
	SystemCoreClockUpdate();
	AutomaticPump_Init();
	ButtonBoard_Init();
	SoilMoisture_Init();
	Led_Init();
	TimeBasic_Init();
	TimerInit();
	ADCSoilMoisture_Init();
	USART2_Init();
	ADC_SoftwareStartConv(ADC1);
	EventButton_Init();
	EventSchedulerInit(AppStateManager);
	SetStateApp(STATE_APP_STARTUP);
	EventSchedulerAdd(EVENT_APP_INIT);
	sensorUpdateTimerId = TimerStart(
								"SensorTask",
								SENSOR_READ_INTERVAL_MS,
								TIMER_REPEAT_FOREVER,
								UpdateSoilHumidity,
								NULL
							);

    /* Loop forever */
	while(1)
	{
		processTimerScheduler();
		processEventScheduler();
		processAutoRunPump();

	}
}

static void TimeBasic_Init(void)
{
	TIM_TimeBaseInitTypeDef	Timer_InitStructure;

	RCC_APB2PeriphClockCmd( RCC_APB2Periph_TIM1, ENABLE);

	Timer_InitStructure.TIM_CounterMode = TIM_CounterMode_Up;

	Timer_InitStructure.TIM_Prescaler = 83;

	Timer_InitStructure.TIM_Period = 999;

	Timer_InitStructure.TIM_ClockDivision = TIM_CKD_DIV1;

	Timer_InitStructure.TIM_RepetitionCounter = 0;

	TIM_TimeBaseInit(TIM1, &Timer_InitStructure);
	TIM_Cmd( TIM1, ENABLE);
}


static void SoilMoisture_Init(void)
{
	GPIO_InitTypeDef	GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd( LAND_GPIO_RCC, ENABLE);
	//Cau hinh chan PA2 cho do am dat
	GPIO_InitStructure.GPIO_Pin = LAND_GPIO_PIN;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_Init( LAND_GPIO_PORT, &GPIO_InitStructure);
}

static void AutomaticPump_Init(void)
{
	GPIO_InitTypeDef	GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd( PUMP_GPIO_RCC, ENABLE);
	//Cau hinh chan PB1 cho bom tu dong
	GPIO_InitStructure.GPIO_Pin = PUMP_GPIO_PIN;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_Init( PUMP_GPIO_PORT, &GPIO_InitStructure);

}


static void Led_Init(void)
{
	GPIO_InitTypeDef	GPIO_InitStructure;

	RCC_AHB1PeriphClockCmd(LED_GPIO_RCC, ENABLE);
	GPIO_InitStructure.GPIO_Pin = LED_GPIO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_Init(LED_GPIO_PORT, &GPIO_InitStructure);
}

static void Led_Control(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, uint8_t status)
{
	if(status == GPIO_PIN_SET)
	{
		GPIO_SetBits(GPIOx, GPIO_Pin);
	}
	else if(status == GPIO_PIN_RESET)
	{
		GPIO_ResetBits(GPIOx, GPIO_Pin);
	}
}

static void ButtonBoard_Init(void)
{
	GPIO_InitTypeDef	GPIO_InitStructure;
//	EXTI_InitTypeDef	EXTI_InitStructure;
//	NVIC_InitTypeDef	NVIC_InitStructure;

	//Cap xung clock cho nut nhan
	RCC_AHB1PeriphClockCmd(BUTTON_GPIO_RCC, ENABLE);
	//Cau hinh chan PB3 cho nut nhan
	GPIO_InitStructure.GPIO_Pin = BUTTON_GPIO_PIN;

	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;

	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;

	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;

	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_Init( BUTTON_GPIO_PORT, &GPIO_InitStructure);

}

static void AutoPump_Control(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, uint8_t status)
{
	if(status == GPIO_PIN_SET)
	{
		GPIO_SetBits(GPIOx, GPIO_Pin);
	}
	else if(status == GPIO_PIN_RESET)
	{
		GPIO_ResetBits(GPIOx, GPIO_Pin);
	}
}

void Delay_ms( uint32_t ms)
{
	while(ms != 0)
	{
		TIM_SetCounter( TIM1, 0);
		while(TIM_GetCounter( TIM1) != 999);
		ms--;
	}
}
static uint8_t Pump_GetLogic(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
	return GPIO_ReadOutputDataBit(GPIOx, GPIO_Pin);
}
static void enableAutoPump(void *pArg)
 {
     (void)pArg; // Không dùng tham số
     autoRunPumpStatus = 1; // Kích hoạt lại chế độ tự động
 }
static void UpdateSoilHumidity(void *pArg) // Thêm tham số void*
 {
 	(void)pArg;

 	uint16_t rawADC;
 	float percent;


 	while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
 	rawADC = ADC_GetConversionValue(ADC1);

 	float adcRange = ADC_VALUE_DRY - ADC_VALUE_WET;
 	if (adcRange <= 0) {
 		percent = (rawADC <= ADC_VALUE_WET) ? 100.0f : 0.0f;
 	} else {
 		percent = 100.0f * (ADC_VALUE_DRY - (float)rawADC) / adcRange;
 	}

 	//0 -> 100%
 	if (percent > 100.0f) {
 		percent = 100.0f;
 	} else if (percent < 0.0f) {
 		percent = 0.0f;
 	}

 	latestHumidityPercent = percent;

 	uint16_t moistureIntToSend = (uint16_t)latestHumidityPercent;
 	while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
 	USART_SendData(USART2, moistureIntToSend);

 }

static void ADCSoilMoisture_Init(void)
{
	ADC_InitTypeDef			ADC_InitStructure;
	ADC_CommonInitTypeDef	ADC_CommonInitStructure;
	//Enable peripheral clocks
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

	ADC_DeInit();

	ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
	ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
	ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
	ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
	ADC_CommonInit(&ADC_CommonInitStructure);

	ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
	ADC_InitStructure.ADC_ScanConvMode = DISABLE;
	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
	ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
	ADC_InitStructure.ADC_NbrOfConversion = 1;
	ADC_Init(ADC1, &ADC_InitStructure);

	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 1, ADC_SampleTime_144Cycles);

//	ADC_TempSensorVrefintCmd(ENABLE);

	ADC_Cmd(ADC1, ENABLE);
}
static void USART2_Init(void)
{

	GPIO_InitTypeDef		GPIO_InitStructure;
	USART_InitTypeDef		USART_InitStructure;
	// Enable GPIO clock
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

	// Configure USART Tx as alternate function push-pull-
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;

	GPIO_InitStructure.GPIO_Pin = USART2_TX;
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	// Connect USART pins-
	GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);

	// Enable USART clock-
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);

	USART_InitStructure.USART_BaudRate = USART2_Baud;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);
	// Enable USART-
	USART_Cmd(USART2, ENABLE);
}

static float GetSoilHumidityPercent(void)
{
 	return latestHumidityPercent;
}
void DeviceStateMachine(uint8_t event)
{
	switch(event)
	{
		case EVENT_OF_BUTTON_2_PRESS_LOGIC:




			if(Pump_GetLogic(PUMP_GPIO_PORT, PUMP_GPIO_PIN) == 1)
			{
				autoRunPumpStatus = 0;
				AutoPump_Control(PUMP_GPIO_PORT, PUMP_GPIO_PIN, GPIO_PIN_RESET);
				Led_Control( LED_GPIO_PORT, LED_GPIO_PIN, GPIO_PIN_RESET);
				currentPumpState = PUMP_IDLE;


				// Hủy timer bật lại auto (nếu đang chạy)
 				if (autoPumpTimerId != NO_TIMER)
 				{
 					TimerStop(autoPumpTimerId); // *** Cần hàm TimerStop ***
 					autoPumpTimerId = NO_TIMER;
 				}

				autoPumpTimerId = TimerStart("AutoTask", 10000, 1, enableAutoPump, NULL); // Em phai goi timer stop o tren no moi huy tac vu hien tai
				// goi duoi day la no tat luon cai tren day

			}else
			{
				autoRunPumpStatus = 1;
				AutoPump_Control(PUMP_GPIO_PORT, PUMP_GPIO_PIN, GPIO_PIN_SET);
				Led_Control( LED_GPIO_PORT, LED_GPIO_PIN, GPIO_PIN_SET);
				currentPumpState = PUMP_RUNNING;
			}
			break;
		default:
			break;
	}
}

static void processAutoRunPump()
{
	if(autoRunPumpStatus == 1)
	{
		float currentHumidity = GetSoilHumidityPercent();
		    switch (currentPumpState)
		    {
		        case PUMP_IDLE:
		            // Kiem tra lien tuc neu do am dat yeu cau thi tat bom
		            if (currentHumidity <= 5.0f)
		            {
		                // Do am thap => Bat bom
		                AutoPump_Control(PUMP_GPIO_PORT, PUMP_GPIO_PIN, GPIO_PIN_SET);
		                Led_Control( LED_GPIO_PORT, LED_GPIO_PIN, GPIO_PIN_SET);
		                // Gan state sang PUMP_RUNNING
		                currentPumpState = PUMP_RUNNING;
		            }
		            break;

		        case PUMP_RUNNING:
		            // Trong khi bom dang chay kiem tra dieu kien do am
		            // Neu do am tren 30 thi tat bom
		            if (currentHumidity >= 10.0f)
		            {
		                // Do am du => Tat bom
		                AutoPump_Control(PUMP_GPIO_PORT, PUMP_GPIO_PIN, GPIO_PIN_RESET);
		                Led_Control( LED_GPIO_PORT, LED_GPIO_PIN, GPIO_PIN_RESET);
		                checkPump = 0;
		                currentPumpState = PUMP_IDLE;
		            }
		            break;
		        default:
					// Trạng thái không xác định -> Chuyển về IDLE và tắt bơm
	 				currentPumpState = PUMP_IDLE;
	 				AutoPump_Control(PUMP_GPIO_PORT, PUMP_GPIO_PIN, GPIO_PIN_RESET);
	 				Led_Control( LED_GPIO_PORT, LED_GPIO_PIN, GPIO_PIN_RESET);
	 				break;
		    }

    }
}
